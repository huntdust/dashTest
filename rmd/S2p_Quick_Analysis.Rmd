---
title: "RF Cable Analysis"
author: "Andrew Yokubaitis"
output: html_document
#date: "`r format(Sys.time(), '%d %B %Y')`"
---

```{r setup, include=FALSE}
# Clear R session
rm(list=ls())

# Prevents java OOM errors when trying to create the excel files
knitr::opts_chunk$set(echo = TRUE, fig.height = 7, fig.width = 10)
options(java.parameters = "-Xmx10g")

#library(openxlsx)
#library(xlsx)
library(readxl)
library(dplyr)
library(data.table)
library(gtools) # enables the mixed sort function
library(ggplot2)
library(reshape2)
library(plotly)
library(readbulk)
library(stringr)
library(tictoc)
#options(digits = 14)
options(dplyr.summarise.inform = FALSE)
##########################
# User defined variables #


# Path to where the data is stored
  # Note: Windows uses "\" in its file names by default and they must be chagned to "/" in the script to function properly
#pth <- "//pilly/jaguar/interface/project/MX-44/Agoura Hills Data Analysis and Pics/Data and Analysis/Gore/Gore_PA_Bit63/Data/All_Data_Every_10th"
#pth <- "C:/R_Programs/Nutcracker_Data/Falcon_Pair_1/Test1"
#pth <- "E:/Teradyne_WFH/Falcon_Cross-Corr_Data/All_Data/Test1"

pth <- "//pilly/jaguar/interface/project/Gryffindor/Data_and_Results/Rosenberger_Cable1/5000_Cycle_Set/Data_Holder"

#pth <- "E:/Teradyne_WFH/Falcon_Cross-Corr_Data/All_Data/Test19"
  #need to redo 11-13 with the new mods that roger requested

company <- "Rosenberger"

cable_name <- "Cable 1 Cycles 1-2160"

# Total number of cycles the cable experienced during the collection of this data set
total_cycles <- 2160

# Sets the Number of cycles between measurements; allows use of less data to lower computation time
cycs_between_meas <- 5

# declare how many cables are included in this data set so that the max phase shift between cables can be correctly calculated
num_cables <- 1

# Defines the number of traces included in a "window" for any of the plots that are calculated in that method
  # Increasing the size of this variable can drastically increase computation time; do so wisely or with testing
window_size <- 8




# Specify if this data is from a Falcon test and should therefore have the adpater losses subtracted from the results
is_falcon <- FALSE

# Set the value and indicator for whether or not to use further sample reduction
reduction_indicator <- FALSE
reduction_count <- 5


# Speficy whether or not to print the name of every data file used during compliation
print_data_names <- FALSE


# Freq to check insertion loss and return loss at to see how it varies over time
desired_freq_high <- 53
desired_freq_low  <- 10


# Specify if which S11 and S21 specs should be used in the plots
  # values can be low, mid, high, or mx44
s11_spec <- "Falcon"
s21_spec <- "Falcon"

# End of User Defined Variables #
#################################


# Get the date the data was taken
first_file <- paste(pth,mixedsort(sort(list.files(pth)))[1], sep = "/")
data_date <- file.mtime(first_file)  # gets date and time the file was created
data_date <- as.character(data_date)
data_date <- strsplit(data_date, split = " ")[[1]][1]

# Names of the variables in the data files from the VNA
n_ri <- c("Freq_GHz","S11_Real","S11_Img","S21_Real","S21_Img","S12_Real","S12_Img","S22_Real","S22_Img")
n_pm <- c("Freq_GHz","S11_dB","S11_Phase_Deg","S21_dB","S21_Phase_Deg","S12_dB","S12_Phase_Deg","S22_dB","S22_Phase_Deg")

# Get the number of data files and their names in order
order <- mixedsort(sort(list.files(pth)))

# Subset the data based on the reduction indicator and reduction coutn variables
if(reduction_indicator){
  order <- order[seq(1, length(order), reduction_count)]
  cycs_between_meas <- cycs_between_meas * reduction_count
}

num_files <- length(order)

# End of User Defined Variables #
#################################

```


```{r Adapter Data, echo = FALSE, eval = FALSE}

# Get the adapter data for the Falcon tests
adapter_pth <- "E:/Teradyne_WFH/Falcon/Dual_Adapter_Meas.s2p"
adapter_loss <- read.delim(adapter_pth, header = FALSE, sep = "", dec = ".", comment.char = "!")

# Delete row with data names
adapter_loss <- adapter_loss[-1,]

# change data to the correct data type
for(k in 1:ncol(adapter_loss)){
    adapter_loss[,k] <- as.numeric(as.character(adapter_loss[,k]))
}

# Change data names
names(adapter_loss) <- n_ri


# Modify the data and create the variables we need
adapter_loss <- adapter_loss %>%
      mutate(`S11_Mag`   = sqrt((`S11_Real`)^2 + (`S11_Img`)^2), 
             `S11_Phase_Rad` = atan(`S11_Img` / `S11_Real`),
             `S11_Phase_Deg` = atan(`S11_Img` / `S11_Real`) * (180/pi),
             `S11_dB`    = 20*log10(sqrt((`S11_Real`)^2 + (`S11_Img`)^2)),
             
             `S12_Mag`   = sqrt((`S12_Real`)^2 + (`S12_Img`)^2),
             `S12_Phase_Rad` = atan(`S12_Img` / `S12_Real`),
             `S12_Phase_Deg` = atan(`S12_Img` / `S12_Real`) * (180/pi),
             `S12_dB`    = 20*log10(sqrt((`S12_Real`)^2 + (`S12_Img`)^2)),

             `S21_Mag`   = sqrt((`S21_Real`)^2 + (`S21_Img`)^2), 
             `S21_Phase_Rad` = atan(`S21_Img` / `S21_Real`),
             `S21_Phase_Deg` = atan(`S21_Img` / `S21_Real`) * (180/pi),
             `S21_dB`    = 20*log10(sqrt((`S21_Real`)^2 + (`S21_Img`)^2)),

             `S22_Mag`   = sqrt((`S22_Real`)^2 + (`S22_Img`)^2), 
             `S22_Phase_Rad` = atan(`S22_Img` / `S22_Real`),
             `S22_Phase_Deg` = atan(`S22_Img` / `S22_Real`) * (180/pi),
             `S22_dB`    = 20*log10(sqrt((`S22_Real`)^2 + (`S22_Img`)^2))
      )


adapter_loss2 <- adapter_loss

# Divide all columns by 2 if not the frequency column
for(k in 1:ncol(adapter_loss)){
    if(k > 1){
      adapter_loss[,k] <- (adapter_loss[,k] / 2)
    }
}


# Create the function that subtracts the adapter losses in the next section if specified by the is_falcon variable
subtract_additional_losses <- function(master_df, loss_table, meas_num){
  
  # Get the data for a measurement
  d <- master_df[which(master_df$meas == meas_num),]
  
  # Subtract the additional losses
  d$S21_dB <- d$S21_dB - loss_table$S21_dB
  
  return(d$S21_dB)
}
```



```{r Data_Transform, echo=FALSE, warning = FALSE}
# This data type indicator is set depending on the format of the data is is used later when converting data to the other format
data_format <- c(0)

#tic("Data aggregation")
if(print_data_names){
  for(i in 1:length(order)){print(paste("Trace", i, "is from file", order[i], sep = " "))}
}

# Create the master data frame
df <- c(0)

# Create a vector to hold the data of the standard deviation calculated every cycle
sd_by_cycle_s21 <- c(0)
sd_by_cycle_phase <- c(0)

# Read in all the data
df <- read_bulk(directory = pth, verbose = FALSE, ## make this false to stop the printing as files are loaded
                fun = read.delim, stringsAsFactors = FALSE, extension = ".s2p", header = FALSE, sep = "", dec = ".", comment.char = "!")

# Rename the data and set the data indicator
if(df$V4[1] == "dB"){
  names(df) <- c(n_pm, "filename")
  data_format <- "dB"
} else if(df$V4[1] == "RI"){
  names(df) <- c(n_ri, "filename")
  data_format <- "RI"
} else {
  print("Data is not in the correct format for this script.")
}
  
  
  
# remove the row of labels from the beginning of each file
df <- df[-which(df$Freq_GHz == "#"),]


# sort the data into the order it was taken in 
df <- df[order(match(df$filename, order)),]


# save the filename column temporarily
filenames <- df[,ncol(df)]

# delete the filename column
df <- df[,-ncol(df)]


# Set the right types for all the data
for(k in 1:ncol(df)){
  df[,k] <- as.numeric(as.character(df[,k]))
}

# Rename the rows to the proper count
row.names(df) <- 1:nrow(df)

###################################################
##### Convert the data to the opposite format #####
###################################################
if(data_format == "dB"){
  df <- df %>%
      mutate(`S11_Real` = `S11_dB` * cos(`S11_Phase_Deg`),
             `S11_Img` = `S11_dB` * sin(`S11_Phase_Deg`),
             
             `S12_Real` = `S12_dB` * cos(`S12_Phase_Deg`),
             `S12_Img` = `S12_dB` * sin(`S12_Phase_Deg`),
             
             `S21_Real` = `S21_dB` * cos(`S21_Phase_Deg`),
             `S21_Img` = `S21_dB` * sin(`S21_Phase_Deg`),
             
             `S22_Real` = `S22_dB` * cos(`S22_Phase_Deg`),
             `S22_Img` = `S22_dB` * sin(`S22_Phase_Deg`),
             
             `S11_Mag`    = 20*log10(sqrt((`S11_Real`)^2 + (`S11_Img`)^2)),
             `S12_Mag`    = 20*log10(sqrt((`S12_Real`)^2 + (`S12_Img`)^2)),
             `S21_Mag`    = 20*log10(sqrt((`S21_Real`)^2 + (`S21_Img`)^2)),
             `S22_Mag`    = 20*log10(sqrt((`S22_Real`)^2 + (`S22_Img`)^2)),
             
             `S11_Phase_Rad` = S11_Phase_Deg * (pi/180),
             `S12_Phase_Rad` = S12_Phase_Deg * (pi/180),
             `S21_Phase_Rad` = S21_Phase_Deg * (pi/180),
             `S22_Phase_Rad` = S22_Phase_Deg * (pi/180), 
             
             `VSWR` = (1 + 10^((S11_dB) / 20)) / (1 - 10^((S11_dB) / 20))


      )
} else if(data_format == "RI"){
  df <- df %>%
      mutate(`S11_Mag`       = sqrt((`S11_Real`)^2 + (`S11_Img`)^2), 
             `S11_Phase_Rad` = atan(`S11_Img` / `S11_Real`),
             `S11_Phase_Deg` = atan(`S11_Img` / `S11_Real`) * (180/pi),
             `S11_dB`        = 20*log10(sqrt((`S11_Real`)^2 + (`S11_Img`)^2)),
             
             `S12_Mag`       = sqrt((`S12_Real`)^2 + (`S12_Img`)^2),
             `S12_Phase_Rad` = atan(`S12_Img` / `S12_Real`),
             `S12_Phase_Deg` = atan(`S12_Img` / `S12_Real`) * (180/pi),
             `S12_dB`        = 20*log10(sqrt((`S12_Real`)^2 + (`S12_Img`)^2)),
             
             `S21_Mag`       = sqrt((`S21_Real`)^2 + (`S21_Img`)^2), 
             `S21_Phase_Rad` = atan(`S21_Img` / `S21_Real`),
             `S21_Phase_Deg` = atan(`S21_Img` / `S21_Real`) * (180/pi),
             `S21_dB`        = 20*log10(sqrt((`S21_Real`)^2 + (`S21_Img`)^2)),
             
             `S22_Mag`       = sqrt((`S22_Real`)^2 + (`S22_Img`)^2), 
             `S22_Phase_Rad` = atan(`S22_Img` / `S22_Real`),
             `S22_Phase_Deg` = atan(`S22_Img` / `S22_Real`) * (180/pi),
             `S22_dB`        = 20*log10(sqrt((`S22_Real`)^2 + (`S22_Img`)^2)),
             
             `VSWR` = (1 + 10^((S11_dB) / 20)) / (1 - 10^((S11_dB) / 20))

  )
} else {
  print("Data is not in the correct format for this script.")
}

###### Calculate the phase and_Magnitude components in dB's of each paramater #####
###################################################################################
# df <- df %>%
#   mutate(`S11_Mag`       = sqrt((`S11_Real`)^2 + (`S11_Img`)^2), 
#          `S11_Phase_Rad` = atan(`S11_Img` / `S11_Real`),
#          `S11_Phase_Deg` = atan(`S11_Img` / `S11_Real`) * (180/pi),
#          `S11_dB`        = 20*log10(sqrt((`S11_Real`)^2 + (`S11_Img`)^2)),
#          
#          `S12_Mag`       = sqrt((`S12_Real`)^2 + (`S12_Img`)^2),
#          `S12_Phase_Rad` = atan(`S12_Img` / `S12_Real`),
#          `S12_Phase_Deg` = atan(`S12_Img` / `S12_Real`) * (180/pi),
#          `S12_dB`        = 20*log10(sqrt((`S12_Real`)^2 + (`S12_Img`)^2)),
#          
#          `S21_Mag`       = sqrt((`S21_Real`)^2 + (`S21_Img`)^2), 
#          `S21_Phase_Rad` = atan(`S21_Img` / `S21_Real`),
#          `S21_Phase_Deg` = atan(`S21_Img` / `S21_Real`) * (180/pi),
#          `S21_dB`        = 20*log10(sqrt((`S21_Real`)^2 + (`S21_Img`)^2)),
#          
#          `S22_Mag`       = sqrt((`S22_Real`)^2 + (`S22_Img`)^2), 
#          `S22_Phase_Rad` = atan(`S22_Img` / `S22_Real`),
#          `S22_Phase_Deg` = atan(`S22_Img` / `S22_Real`) * (180/pi),
#          `S22_dB`        = 20*log10(sqrt((`S22_Real`)^2 + (`S22_Img`)^2))
#   )
###################################################################################




# create the meas column
meas <- c(0)
for(i in 1:num_files){
  if(i == 1){
    meas <- rep(i,length(unique(df$Freq_GHz)))
  } else {
    meas <- c(meas, rep(i,length(unique(df$Freq_GHz))))
  }
}

# add the meas count to the data set
df <- cbind(df, meas)

# rebind the filenames column
df <- cbind(df, filenames)

# Create the cycle variable
df <- df %>% mutate(Cycle = meas * cycs_between_meas)


# Subtract the adapter losses if desired
new_S21_dB <- c(0)
if(is_falcon){
  for(i in 1:length(unique(df$meas))){
    if(i == 1){
      new_S21_dB <- subtract_additional_losses(df, adapter_loss, i)
    } else {
      new_S21_dB <- c(new_S21_dB, subtract_additional_losses(df, adapter_loss, i))
    }
  }
  df$S21_dB <- new_S21_dB
  names(df)[names(df) == 'new_S21_dB'] <- 'S21_dB'
}



# Create the sd_by_cycle columns
sd_by_cycle_s21 <- c(0)
sd_by_cycle_phase <- c(0)
for(i in 1:num_files){
  if(i == 1){
    sd_by_cycle_s21 <- rep(0,length(unique(df$Freq_GHz)))
    sd_by_cycle_phase <- rep(0,length(unique(df$Freq_GHz)))
  } else {
    # get the data up to the current cycle
    temp_df <- df[which(df$meas <= i),]
    
    # calculate the sd values up through the current cycle
    total_sd <- group_by(temp_df,`Freq_GHz`) %>%
      summarise( sd_by_cycle_s21 = sd(`S21_dB`), sd_by_cycle_phase = sd(abs(`S21_Phase_Deg`)))
    
    # Add the sd data to sd_by_cycle vectors
    sd_by_cycle_s21 <- c(sd_by_cycle_s21,total_sd$sd_by_cycle_s21)
    sd_by_cycle_phase <- c(sd_by_cycle_phase,total_sd$sd_by_cycle_phase)
    
  }
}


df <- cbind(df, sd_by_cycle_s21, sd_by_cycle_phase)

df$Freq_GHz <- df$Freq_GHz / 1000000000 


                    
# # Remove any data at a freq higher than 43.5 GHz
#df <- df[which(df$`Freq_GHz` < 43510000000),]

#toc()
```


```{r Summary, echo=FALSE, warning=FALSE}
##### Calculate Summary Statistics #####
########################################
#get summary stats for each param
smry <- group_by(df,`Freq_GHz`) %>%
  summarise(
    mean_S11R = mean(`S11_Real`), sd_S11R = sd(`S11_Real`), max_S11R = max(`S11_Real`), min_S11R = min(`S11_Real`),
    mean_S11I = mean(`S11_Img`),  sd_S11I = sd(`S11_Img`),  max_S11I = max(`S11_Img`),  min_S11I = min(`S11_Img`),

    mean_S12R = mean(`S12_Real`), sd_S12R = sd(`S12_Real`), max_S12R = max(`S12_Real`), min_S12R = min(`S12_Real`),
    mean_S12I = mean(`S12_Img`),  sd_S12I = sd(`S12_Img`),  max_S12I = max(`S12_Img`),  min_S12I = min(`S12_Img`),

    mean_S21R = mean(`S21_Real`), sd_S21R = sd(`S21_Real`), max_S21R = max(`S21_Real`), min_S21R = min(`S21_Real`),
    mean_S21I = mean(`S21_Img`),  sd_S21I = sd(`S21_Img`),  max_S21I = max(`S21_Img`),  min_S21I = min(`S21_Img`),

    mean_S22R = mean(`S22_Real`), sd_S22R = sd(`S22_Real`), max_S22R = max(`S22_Real`), min_S22R = min(`S22_Real`),
    mean_S22I = mean(`S22_Img`),  sd_S22I = sd(`S22_Img`),  max_S22I = max(`S22_Img`),  min_S22I = min(`S22_Img`),

    mean_S11_Mag   = mean(`S11_Mag`),   sd_S11_Mag   = sd(`S11_Mag`),   max_S11_Mag   = max(`S11_Mag`),   min_S11_Mag   = min(`S11_Mag`),
    mean_S11_Phase_Rad = mean(`S11_Phase_Rad`), sd_S11_Phase_Rad = sd(`S11_Phase_Rad`), max_S11_Phase_Rad = max(`S11_Phase_Rad`), min_S11_Phase_Rad = min(`S11_Phase_Rad`),
    mean_S11_Phase_Deg = mean(`S11_Phase_Deg`), sd_S11_Phase_Deg = sd(`S11_Phase_Deg`), max_S11_Phase_Deg = max(`S11_Phase_Deg`), min_S11_Phase_Deg = min(`S11_Phase_Deg`),
    mean_S11_dB    = mean(`S11_dB`),    sd_S11_dB    = sd(`S11_dB`),    max_S11_dB    = max(`S11_dB`),    min_S11_dB    = min(`S11_dB`),

    mean_S12_Mag   = mean(`S12_Mag`),   sd_S12_Mag   = sd(`S12_Mag`),   max_S12_Mag   = max(`S12_Mag`),   min_S12_Mag   = min(`S12_Mag`),
    mean_S12_Phase_Rad = mean(`S12_Phase_Rad`), sd_S12_Phase_Rad = sd(`S12_Phase_Rad`), max_S12_Phase_Rad = max(`S12_Phase_Rad`), min_S12_Phase_Rad = min(`S12_Phase_Rad`),
    mean_S12_Phase_Deg = mean(`S12_Phase_Deg`), sd_S12_Phase_Deg = sd(`S12_Phase_Deg`), max_S12_Phase_Deg = max(`S12_Phase_Deg`), min_S12_Phase_Deg = min(`S12_Phase_Deg`),
    mean_S12_dB    = mean(`S12_dB`),    sd_S12_dB    = sd(`S12_dB`),    max_S12_dB    = max(`S12_dB`),    min_S12_dB    = min(`S12_dB`),

    mean_S21_Mag   = mean(`S21_Mag`),   sd_S21_Mag   = sd(`S21_Mag`),   max_S21_Mag   = max(`S21_Mag`),   min_S21_Mag   = min(`S21_Mag`),
    mean_S21_Phase_Rad = mean(`S21_Phase_Rad`), sd_S21_Phase_Rad = sd(`S21_Phase_Rad`), max_S21_Phase_Rad = max(`S21_Phase_Rad`), min_S21_Phase_Rad = min(`S21_Phase_Rad`),
    mean_S21_Phase_Deg = mean(`S21_Phase_Deg`), sd_S21_Phase_Deg = sd(`S21_Phase_Deg`), max_S21_Phase_Deg = max(`S21_Phase_Deg`), min_S21_Phase_Deg = min(`S21_Phase_Deg`),
    mean_S21_dB    = mean(`S21_dB`),    sd_S21_dB    = sd(`S21_dB`),    max_S21_dB    = max(`S21_dB`),    min_S21_dB    = min(`S21_dB`),

    mean_S22_Mag   = mean(`S22_Mag`),   sd_S22_Mag   = sd(`S22_Mag`),   max_S22_Mag   = max(`S22_Mag`),   min_S22_Mag   = min(`S22_Mag`),
    mean_S22_Phase_Rad = mean(`S22_Phase_Rad`), sd_S22_Phase_Rad = sd(`S22_Phase_Rad`), max_S22_Phase_Rad = max(`S22_Phase_Rad`), min_S22_Phase_Rad = min(`S22_Phase_Rad`),
    mean_S22_Phase_Deg = mean(`S22_Phase_Deg`), sd_S22_Phase_Deg = sd(`S22_Phase_Deg`), max_S22_Phase_Deg = max(`S22_Phase_Deg`), min_S22_Phase_Deg = min(`S22_Phase_Deg`),
    mean_S22_dB    = mean(`S22_dB`),    sd_S22_dB    = sd(`S22_dB`),    max_S22_dB    = max(`S22_dB`),    min_S22_dB    = min(`S22_dB`)
  )
```


```{r Create Specs, echo = FALSE}

######### Find the closest freqs in the data set to the desired freqs #########
closest_freq_low <- df$Freq_GHz[which(abs(df$Freq_GHz - desired_freq_low) == min(abs(df$Freq_GHz - desired_freq_low)))][1]
closest_freq_high <- df$Freq_GHz[which(abs(df$Freq_GHz - desired_freq_high) == min(abs(df$Freq_GHz - desired_freq_high)))][1]


######### DF Data table specs #########

# S11 Spec - DEFINED BY HIGH 5 SPECS and used if s11_spec variable is set to mx44
df <- df %>% mutate(S11_spec_mx44 = ifelse(`Freq_GHz` <= 12.5 , -18,
                               ifelse(`Freq_GHz` > 12.5 & `Freq_GHz` <= 21, -15,
                               ifelse(`Freq_GHz` > 21   & `Freq_GHz` <= 29, -14,
                               ifelse(`Freq_GHz` > 29   & `Freq_GHz` <= 40, -13,
                               ifelse(`Freq_GHz` > 40, -12,NA))))))


# Specs for Falcon as defined in the RF Specs presentation from Roger Sinsheimer
df <- df %>% mutate(S11_spec_falcon = ifelse(`Freq_GHz` <= 3, -25,
                                      ifelse(`Freq_GHz` > 3    & `Freq_GHz` <= 8, -20,
                                      ifelse(`Freq_GHz` > 8    & `Freq_GHz` <= 12, -18,
                                      ifelse(`Freq_GHz` > 12   & `Freq_GHz` <= 20, -16,
                                      ifelse(`Freq_GHz` > 20   & `Freq_GHz` <= 24, -15,
                                      ifelse(`Freq_GHz` > 24   & `Freq_GHz` <= 54.2, -13,
                                      ifelse(`Freq_GHz` > 54.2 & `Freq_GHz` <= 70, -11,
                                      ifelse(`Freq_GHz` > 70, -10, NA)))))))))



# S11 Spec pass/fail indicator
df <- df %>% mutate(pass_S11_spec = ifelse(`S11_dB` < S11_spec_falcon, TRUE, FALSE))


###################
### COLIN SPECS ###
###################

# S11 spec defined from Colin Chow's spec sheet
df <- df %>% mutate(S11_spec_low = ifelse(`Freq_GHz` <= 3 , -25,
                               ifelse(`Freq_GHz` > 3 & `Freq_GHz` <= 6, -20,
                               ifelse(`Freq_GHz` > 6 & `Freq_GHz` <= 8, -20,NA))))

df <- df %>% mutate(S11_spec_mid = ifelse(`Freq_GHz` <= 6 , NA,
                               ifelse(`Freq_GHz` > 6  & `Freq_GHz` <= 12, -18,
                               ifelse(`Freq_GHz` > 12 & `Freq_GHz` <= 24, -15, NA))))

df <- df %>% mutate(S11_spec_high = ifelse(`Freq_GHz` <= 20 , NA,
                               ifelse(`Freq_GHz` > 20 & `Freq_GHz` <= 24, -16,
                               ifelse(`Freq_GHz` > 24 & `Freq_GHz` <= 44, -13,
                               ifelse(`Freq_GHz` > 44 & `Freq_GHz` <= 53, -13, NA)))))

# S21 Speclow band- These specs were defined from Colin Chow in the RF mm-Wave Signal Delivery Requirements spreadsheet
df <- df %>% mutate(S21_spec_low = ifelse(`Freq_GHz` <= 3, -1,
                               ifelse(`Freq_GHz` > 3 & `Freq_GHz` <= 6, -1.6,
                               ifelse(`Freq_GHz` > 6 & `Freq_GHz` <= 8, -2, NA))))

# S21 Spec - mid band
df <- df %>% mutate(S21_spec_mid = ifelse(`Freq_GHz` <= 6, -2.4,
                               ifelse(`Freq_GHz` > 6 & `Freq_GHz` <= 12, -3.1,
                               ifelse(`Freq_GHz` > 12 & `Freq_GHz` <= 24, -4.2, NA))))

# S21 Spec - high band
df <- df %>% mutate(S21_spec_high = ifelse(`Freq_GHz` <= 20, NA,
                               ifelse(`Freq_GHz` > 20 & `Freq_GHz` <= 24, -4,
                               ifelse(`Freq_GHz` > 24 & `Freq_GHz` <= 44, -5.4,
                               ifelse(`Freq_GHz` > 44 & `Freq_GHz` <= 53, -6, NA)))))

# S21 Spec - For the Falcon Project
df <- df %>% mutate(S21_spec_falcon = ifelse(`Freq_GHz` <= 3, -1,
                                      ifelse(`Freq_GHz` > 3 & `Freq_GHz` <= 6,     -1.6,
                                      ifelse(`Freq_GHz` > 6 & `Freq_GHz` <= 8,     -2,
                                      ifelse(`Freq_GHz` > 8 & `Freq_GHz` <= 12,    -3.1,
                                      ifelse(`Freq_GHz` > 12 & `Freq_GHz` <= 24,   -4,
                                      ifelse(`Freq_GHz` > 24 & `Freq_GHz` <= 44,   -5.4,
                                      ifelse(`Freq_GHz` > 44 & `Freq_GHz` <= 54.2, -6,
                                      ifelse(`Freq_GHz` > 54.2 & `Freq_GHz` <= 70, -7,
                                      ifelse(`Freq_GHz` > 70   & `Freq_GHz` <= 90, -8.1, NA))))))))))


# S21 Flatness over modulation spec
df <- df %>% mutate(S21_flatness_spec = 0.4)

df <- df %>% mutate(S21_flatness_bw_low = ifelse(`Freq_GHz` <= 8, .4, NA))                      # .4 is .4 GHz which is 400 MHz

df <- df %>% mutate(S21_flatness_bw_mid = ifelse(`Freq_GHz` >= 6 & `Freq_GHz` <= 24, .8, NA))   # .8 is .8 GHz which is 800 MHz

df <- df %>% mutate(S21_flatness_bw_high = ifelse(`Freq_GHz` >= 20 & `Freq_GHz` <= 53, .8, NA)) # .8 is .8 GHz which is 800 MHz


# S21 Max rate of change obver calibration frequecy step
  # "Calibration freq step" defined as 20 MHz in the spec doc

#MIGHT NOT NEED THESE
S21_cal_step_size = .02       # this is 20 MHz
S21_cal_step_max_slope = .2   # this is in dB

### Max shift of S11 or S22 in the complex plane
df <- df %>% mutate(max_S11_shift_low = ifelse(`Freq_GHz` <= 3, -48,
                                        ifelse(`Freq_GHz` > 3 & `Freq_GHz` <= 6, -46,
                                        ifelse(`Freq_GHz` > 6 & `Freq_GHz` <= 8, -45, NA))))

df <- df %>% mutate(max_S11_shift_mid = ifelse(`Freq_GHz` <= 6, NA,
                                        ifelse(`Freq_GHz` > 6 & `Freq_GHz` <= 12, -42,
                                        ifelse(`Freq_GHz` > 12 & `Freq_GHz` <= 24, -42, NA))))

df <- df %>% mutate(max_S11_shift_high = ifelse(`Freq_GHz` <= 20, NA,
                                        ifelse(`Freq_GHz` > 20 & `Freq_GHz` <= 24, -42,
                                        ifelse(`Freq_GHz` > 24 & `Freq_GHz` <= 44, -42,
                                        ifelse(`Freq_GHz` > 44 & `Freq_GHz` <= 53, -42, NA)))))










# S21 Spec pass/fail indicator
#df <- df %>% mutate(pass_S21_spec = ifelse(`S21_dB` > S21_spec, TRUE, FALSE))


#S21 standard deviation spec - first low spec
df <- df %>% mutate(S21_Stdev_spec_low = ifelse(`Freq_GHz` <= 20, 0.016667,
                                         ifelse(`Freq_GHz` > 20 & `Freq_GHz` <= 40, 0.025,   # CHANGE 40 to 28
                                         ifelse(`Freq_GHz` > 28,0.033,NA))))

# S21_rep_spec <- data.table(c(20,28,), c(0.016667,0.025,0.033))
# names(S21_rep_spec) <- c("break_freq","spec")


#S21 standard deviation spec - second x3 spec
df <- df %>% mutate(S21_Stdev_spec_high = ifelse(`Freq_GHz` <= 6, NA,
                                          ifelse(`Freq_GHz` > 6 & `Freq_GHz` <= 25,0.04,
                                          ifelse(`Freq_GHz` > 25 & `Freq_GHz` <= 30,0.0666667,
                                          ifelse(`Freq_GHz` > 30 & `Freq_GHz` <= 43.5 ,0.12666667,
                                          ifelse(`Freq_GHz` >= 43.5 , NA,NA))))))

#S21 standard deviation spec for Falcon
df <- df %>% mutate(S21_Stdev_spec_falcon = ifelse(`Freq_GHz` <= 3, .03,
                                            ifelse(`Freq_GHz` > 3 & `Freq_GHz` <= 6, 0.046,
                                            ifelse(`Freq_GHz` > 6 & `Freq_GHz` <= 8, 0.052,
                                            ifelse(`Freq_GHz` > 8 & `Freq_GHz` <= 12, 0.1,
                                            ifelse(`Freq_GHz` > 12 & `Freq_GHz` <= 24, 0.2,
                                            ifelse(`Freq_GHz` > 24 & `Freq_GHz` <= 54.2, 0.35,
                                            ifelse(`Freq_GHz` >= 54.2, NA,NA))))))))


# S11 Vector error spec
df <- df %>% mutate(S11_Vect_Err_spec = ifelse(`Freq_GHz` <= 6, NA,
                                        ifelse(`Freq_GHz` > 6 & `Freq_GHz` <= 12,0.01,
                                        ifelse(`Freq_GHz` > 12 & `Freq_GHz` <= 20,0.025,
                                        ifelse(`Freq_GHz` > 20 & `Freq_GHz` <= 40,0.05,
                                        ifelse(`Freq_GHz` > 40 & `Freq_GHz` <= 43.5 ,0.075,
                                        ifelse(`Freq_GHz` >= 43.5 , NA,NA)))))))


##### Smry data table specs ########

# S21 High Repeatability spec 
smry <- smry %>% mutate(S21_Stdev_spec_high = ifelse(`Freq_GHz` <= 6, NA,
                                          ifelse(`Freq_GHz` > 6 & `Freq_GHz` <= 25,0.04,
                                          ifelse(`Freq_GHz` > 25 & `Freq_GHz` <= 30,0.0666667,
                                          ifelse(`Freq_GHz` > 30 & `Freq_GHz` <= 43.5 ,0.12666667,
                                          ifelse(`Freq_GHz` >= 43.5 , NA,NA))))))

# provides values in areas the given specs dont cover in order to allow the pass/fail readout to runction properly
smry <- smry %>% mutate(S21_Stdev_spec_high_eval = ifelse(`Freq_GHz` <= 6, 100,
                                          ifelse(`Freq_GHz` > 6 & `Freq_GHz` <= 25,0.04,
                                          ifelse(`Freq_GHz` > 25 & `Freq_GHz` <= 30,0.0666667,
                                          ifelse(`Freq_GHz` > 30 & `Freq_GHz` <= 43.5 ,0.12666667,
                                          ifelse(`Freq_GHz` >= 43.5 , 100,NA))))))


#S21 standard deviation spec for Falcon
smry <- smry %>% mutate(S21_Stdev_spec_falcon = ifelse(`Freq_GHz` <= 3, .03,
                                            ifelse(`Freq_GHz` > 3 & `Freq_GHz` <= 6, 0.046,
                                            ifelse(`Freq_GHz` > 6 & `Freq_GHz` <= 8, 0.052,
                                            ifelse(`Freq_GHz` > 8 & `Freq_GHz` <= 12, 0.1,
                                            ifelse(`Freq_GHz` > 12 & `Freq_GHz` <= 24, 0.2,
                                            ifelse(`Freq_GHz` > 24 & `Freq_GHz` <= 44, 0.35,
                                            ifelse(`Freq_GHz` > 44 & `Freq_GHz` <= 53, 0.35,
                                            ifelse(`Freq_GHz` >= 53, NA,NA)))))))))




# S21 Repeatability spec pass/fail indicator
smry <- smry %>% mutate(pass_S21_Stdev_spec_high = ifelse(sd_S21_dB < S21_Stdev_spec_high_eval, TRUE, FALSE))

# S21 Low Repeatability spec 
smry <- smry %>% mutate(S21_Stdev_spec_low = ifelse(`Freq_GHz` <= 20, 0.016667,
                                             ifelse(`Freq_GHz` > 20 & `Freq_GHz` <= 40,0.025,
                                             ifelse(`Freq_GHz` > 28,0.033,NA))))

# S21 Repeatability spec pass/fail indicator
smry <- smry %>% mutate(pass_S21_Stdev_spec_low = ifelse(sd_S21_dB < S21_Stdev_spec_low, TRUE, FALSE))


```


## S-Paramater Analysis


#### Plot 1.1: All S21 Data

This plot is used to visualize the S21 data taken over the course of the `r total_cycles` mating cycles on the `r company` `r cable_name`. The color of each trace corresponds to which mating cycle the data sample was taken on with red indicating earlier measurements and purple indicating later measurements.

```{r Plotting1.1, echo = FALSE, warning = FALSE}
# Load the Gore predicted loss data
gore <- read_xlsx(path = "E:/Teradyne_WFH/Gore_Insertion_Loss_Curves.xlsx", sheet = 4)
names(gore) <- c("Frequency", "Gauranteed Worst Loss")
gore <- gore[which(gore$Frequency < 67),]



# Load the data
df_melt_S21 <- melt(df, id.vars = c("Freq_GHz","Cycle","S21_spec_low","S21_spec_mid","S21_spec_high", "S21_spec_falcon"), measure.vars = c("S21_dB"))
names(df_melt_S21) <- c("Frequency", "Cycle", "S21_spec_low","S21_spec_mid","S21_spec_high", "S21_spec_falcon", "variable", "Loss")

# Create the plot    
title <- "Insertion Loss vs Frequency"
p <- ggplot(data = df_melt_S21, mapping = aes(x = Frequency)) +
  geom_line(size = 0.5, aes(y = Loss, color = Cycle)) +
  labs(x = "Frequency (GHz)", y = "Magnitude of S21 (dB)", col = "Cycle") +
  ggtitle(title) +
  scale_color_gradientn(colors = rainbow(5))



# Add specs to the plot if desired
if(s21_spec == "low"){
  spec_table <- data.table(df_melt_S21$Frequency[which(df_melt_S21$Cycle == 1)], df_melt_S21$S21_spec_low[which(df_melt_S21$Cycle == 1)])
  names(spec_table) <- c("Frequency", "Spec")
  p <- p + geom_line(data = spec_table, aes(y = Spec), color = "red")
} else if (s21_spec == "mid"){
  spec_table <- data.table(df_melt_S21$Frequency[which(df_melt_S21$Cycle == 1)], df_melt_S21$S21_spec_mid[which(df_melt_S21$Cycle == 1)])
  names(spec_table) <- c("Frequency", "Spec")
  p <- p + geom_line(data = spec_table, aes(y = Spec), color = "red")
} else if (s21_spec == "high"){
  spec_table <- data.table(df_melt_S21$Frequency[which(df_melt_S21$Cycle == 1)], df_melt_S21$S21_spec_high[which(df_melt_S21$Cycle == 1)])
  names(spec_table) <- c("Frequency", "Spec")
  p <- p + geom_line(data = spec_table, aes(y = Spec), color = "red")
} else if (s21_spec == "Falcon"){
  spec_table <- data.table(df_melt_S21$Frequency[which(df_melt_S21$Cycle == 1)], df_melt_S21$S21_spec_falcon[which(df_melt_S21$Cycle == 1)])
  names(spec_table) <- c("Frequency", "Spec")
  p <- p + geom_line(data = spec_table, aes(y = Spec), color = "red")
}


# Add the line for the worst case gore losses
p <- p + geom_line(data = gore, aes(y = `Gauranteed Worst Loss`), color = "black")



# Generate the plot
p21 <- ggplotly(p, dynamicTicks = TRUE) %>% layout(xaxis = list(autorange = FALSE))
p21 <- config(p21, modeBarButtonsToRemove = c("zoomIn2d", "zoomOut2d", "lasso2d", "select2d", "toggleSpikelines","autoScale2d"))
p21
```
<center> TERADYNE CONFIDENTIAL DO NOT DISTRIBUTE </center>  




#### Plot 1.3: Max, Min, and Mean of S21

This plot is used to calculate and visualize the maximum, minimum, and mean of S21 at each frequency over the `r total_cycles` cycles preformed on the `r company` `r cable_name`:

```{r Plotting1.3, echo = FALSE, warning = FALSE}
# Standard deviation of S21 across frequencies

# Create the title
title <- "Insertion Loss Max, Min, and Mean"

# Grab the needed subset of data
temp <- data.frame(smry$Freq_GHz, smry$max_S21_dB, smry$min_S21_dB, smry$mean_S21_dB)
names(temp) <- c("Frequency", "Max S21", "Min S21", "Mean S21")

# Create the plot
p <- ggplot(data = temp, mapping = aes(x = Frequency)) +
     geom_line(aes(y = `Max S21`), color = "red") +
     labs(x = "Frequency (GHz)", y = "Magnitude of S21 (dB)") +
     ggtitle(title)# +


      
# Add the max and min lines to the plot
p <- p + geom_line(aes(y = `Min S21`), color = "blue") +
         geom_line(aes(y = `Mean S21`), color = "black") +
         #labs(x = "Frequency (GHz)", y = "Spec")
         theme(legend.position = "none")

# Load the Gore predicted loss data
gore <- read_xlsx(path = "E:/Teradyne_WFH/Gore_Insertion_Loss_Curves.xlsx", sheet = 4)
names(gore) <- c("Frequency", "Gauranteed Worst Loss")
gore <- gore[which(gore$Frequency < 67),]

p <- p + geom_line(data = gore, aes(y = `Gauranteed Worst Loss`), color = "black")



# Plot it (Dynamic tics enables scale changes when zooming; autorange=false enables a small buffer around the data instead of taking it to the edges of the plots)
# Generate the plot
p21mmm <- ggplotly(p, dynamicTicks = TRUE) %>% layout(xaxis = list(autorange = FALSE))
p21mmm <- config(p21mmm, modeBarButtonsToRemove = c("zoomIn2d", "zoomOut2d", "lasso2d", "select2d", "toggleSpikelines","autoScale2d"))
p21mmm
```
<center> TERADYNE CONFIDENTIAL DO NOT DISTRIBUTE </center>  



#### Plot 2.1: S21 Standard Deviation Over All Cycles

This plot is used to calculate and visualize the standard deviation of S21 at all frequencies over the `r total_cycles` cycles preformed on the `r company` `r cable_name`:

```{r Plotting2.1, echo = FALSE, warning = FALSE}
# Standard deviation of S21 across frequencies
coverage_factor <- 3

# Create the title
title <- "Insertion Loss Repeatability: Standard Deviation of S21"

# Grab the needed subset of data
temp <- data.frame(smry$Freq_GHz, smry$sd_S21_dB, smry$S21_Stdev_spec_high, smry$S21_Stdev_spec_low, smry$S21_Stdev_spec_falcon)
names(temp) <- c("Frequency", "Repeatability (dB)", "Current Spec", "Previous spec", "Spec")
temp$`Repeatability (dB)` <- temp$`Repeatability (dB)` * coverage_factor

# Create the plot
p <- ggplot(data = temp, mapping = aes(x = Frequency)) +
     geom_line(aes(y = `Repeatability (dB)`)) +
     labs(x = "Frequency (GHz)", y = "Standard Deviation of S21 (dB)") +
     ggtitle(title)# +


      
# Add the spec line to the plot
if(s21_spec == "Falcon"){
  p <- p + geom_line(aes(y = `Spec`), color = "red") +
         theme(legend.position = "none")
} else {
  p <- p + geom_line(aes(y = `Current Spec`), color = "red") +
         geom_line(aes(y = `Previous spec`), color = "blue") +
         theme(legend.position = "none")
}




# Plot it
# Generate the plot
p21r <- ggplotly(p, dynamicTicks = TRUE) %>% layout(xaxis = list(autorange = FALSE))
p21r <- config(p21r, modeBarButtonsToRemove = c("zoomIn2d", "zoomOut2d", "lasso2d", "select2d", "toggleSpikelines","autoScale2d"))
p21r

#Pass or fail old (low) repeatability spec: `r if(sum(!smry$pass_S21_Stdev_spec_low) > 0){paste("FAILED")} else {paste("PASS")}`  
#Pass or fail new (high) repeatability spec: `r if(sum(!smry$pass_S21_Stdev_spec_high) > 0){paste("FAILED")} else {paste("PASS")}`


```

<center> TERADYNE CONFIDENTIAL DO NOT DISTRIBUTE </center>  


#### Plot 2.2: S21 Standard Deviation Calculated After Each Cycle

This plot is used to calculate and visualize the standard deviation of S21 at all frequencies over the `r total_cycles` cycles preformed on the `r company` `r cable_name`. Measurements were taken every `r cycs_between_meas` cycles for a total of `r length(list.files(pth))` measurements. The standard deviation was recalculated after every measurement to see how the standard deviation changed over time and if/when it failed the repeatability specification:

```{r Plotting2.2, echo = FALSE, warning = FALSE}
coverage_factor <- 3


#temp_df <- df[which(df$sd_by_cycle_s21 > 0),]

temp <- data.frame(df$Freq_GHz, df$sd_by_cycle_s21, df$S21_Stdev_spec_high, df$S21_Stdev_spec_low, df$S21_Stdev_spec_falcon, df$Cycle)
names(temp) <- c("Frequency","Repeatability","Current Spec", "Previous Spec", "Spec", "Cycle")
temp <- temp[which(temp$Repeatability > 0),]
temp$Repeatability <- temp$Repeatability * coverage_factor

# Create the plot title
title <- "Insertion Loss Repeatability: Standard Deviation of S21 Calculated Every Cycle"

# Create the plot
p <- ggplot(data = temp, mapping = aes(x = Frequency)) + 
  geom_line(aes(y = Repeatability, color = Cycle)) +
  labs(x = "Frequency (GHz)", y = "Standard Deviation of S21 (dB)", col = "Cycle") + 
  ggtitle(title) +
  scale_color_gradientn(colors = rainbow(5)) +
  guides(fill=guide_legend(title="Cycle"))

# create a mini data table for the specs so there are not hundreds of spec lines overlayed and taking up storage space
  #THIS IS NOT WORKING CORRECTLY, NEED TO CREATE LOOP TO BACK OUT THE SPECS AND BREAK FREQS, THEN USE GEOM_SEGMENT TO PLOT THE DIFFERENT SEGMENTS
m <- min(temp$Cycle)
spec <- temp[which(temp$Cycle == m),]  

# Add the spec line to the plot
if(s21_spec == "Falcon"){
  p <- p + geom_line(aes(y = `Spec`), color = "red") +
         theme(legend.position = "none")
} else {
  p <- p + geom_line(aes(y = `Current Spec`), color = "red") +
         geom_line(aes(y = `Previous spec`), color = "blue") +
         theme(legend.position = "none")
}

# Generate the plot
p21rcyc <- ggplotly(p, dynamicTicks = TRUE) %>% layout(xaxis = list(autorange = FALSE))
p21rcyc <- config(p21rcyc, modeBarButtonsToRemove = c("zoomIn2d", "zoomOut2d", "lasso2d", "select2d", "toggleSpikelines","autoScale2d"))
p21rcyc

# Create pass/fail statement for low spec
if(sum(df$sd_by_cycle_s21 > df$S21_Stdev_spec_low) > 0){
  pfl <- paste("FAILED LOW SPEC ON CYCLE ", df$Cycle[which(df$sd_by_cycle_s21 > df$S21_Stdev_spec_low)[1]], " OUT OF ", total_cycles, " CYCLES", sep = "")
} else {pfl <- paste("PASS")}

# Create pass/fail statement for high spec
if(sum(df$sd_by_cycle_s21 > df$S21_Stdev_spec_high, na.rm = TRUE) > 0){
  pfh <- paste("FAILED HIGH SPEC ON CYCLE ", df$Cycle[which(df$sd_by_cycle_s21 > df$S21_Stdev_spec_high)[1]],  " OUT OF ", total_cycles, " CYCLES", sep = "")
} else {pfh <- paste("PASS")}


#Pass or fail old (low) repeatability spec: `r pfl`        
#Pass or fail new (high) repeatability spec: `r pfh`


```

<center> TERADYNE CONFIDENTIAL DO NOT DISTRIBUTE </center>  



#### Plot 3.1: S21 Data at `r closest_freq_low` GHz

This plot is the same as the above plot but the data was taken at `r closest_freq_low` GHz instead of `r closest_freq_high` GHz. This plot can be used to get an idea of how the cable is degrading over time.

```{r Plotting3.1, echo = FALSE}
# Plot all S21 from all measurements
df_melt_S21 <- melt(df, id.vars = c("Freq_GHz","Cycle"), measure.vars = c("S21_dB"))

df_melt_S21_select_freq <- df_melt_S21[which(df_melt_S21$`Freq_GHz` == closest_freq_low),]
names(df_melt_S21_select_freq) <- c("Frequency", "Cycle", "variable", "Insertion Loss")


title <- paste("S21 Data at ", closest_freq_low, " GHz over ", total_cycles, " cycles", sep = "")  

p <- ggplot(data = df_melt_S21_select_freq, mapping = aes(x = Cycle, y = `Insertion Loss`)) + 
     geom_line() +
     labs(x = "Cycle", y = "S21") + 
     xlab("Cycle Number") + 
     ylab("Magnitude of S21 (dB)") + 
     ggtitle(title) 

# Generate the plot
p21freql <- ggplotly(p, dynamicTicks = TRUE) %>% layout(xaxis = list(autorange = FALSE))
p21freql <- config(p21freql, modeBarButtonsToRemove = c("zoomIn2d", "zoomOut2d", "lasso2d", "select2d", "toggleSpikelines","autoScale2d"))
p21freql
```
<center> TERADYNE CONFIDENTIAL DO NOT DISTRIBUTE </center>  



#### Plot 3.2: S21 Data at `r closest_freq_high` GHz

This plot is used to visualize the S21 data taken at `r closest_freq_high` GHz over the course of the `r length(list.files(pth))` measurements on the `r company` `r cable_name`. This plot can be used to get an idea of how the cable is degrading over time.

```{r Plotting3.2, echo = FALSE}
# Plot all S21 from all measurements
df_melt_S21 <- melt(df, id.vars = c("Freq_GHz","Cycle"), measure.vars = c("S21_dB"))

df_melt_S21_select_freq <- df_melt_S21[which(df_melt_S21$`Freq_GHz` == closest_freq_high),]
names(df_melt_S21_select_freq) <- c("Frequency", "Cycle", "variable", "Insertion Loss")


title <- paste("S21 Data at ", closest_freq_high, " GHz over ", total_cycles, " cycles", sep = "")  

p <- ggplot(data = df_melt_S21_select_freq, mapping = aes(x = Cycle, y = `Insertion Loss`)) + 
     geom_line() +
     labs(x = "Cycle", y = "S21") + 
     xlab("Cycle Number") + 
     ylab("Magnitude of S21 (dB)") + 
     ggtitle(title) 

# Generate the plot
p21freqh <- ggplotly(p, dynamicTicks = TRUE) %>% layout(xaxis = list(autorange = FALSE))
p21freqh <- config(p21freqh, modeBarButtonsToRemove = c("zoomIn2d", "zoomOut2d", "lasso2d", "select2d", "toggleSpikelines","autoScale2d"))
p21freqh
```
<center> TERADYNE CONFIDENTIAL DO NOT DISTRIBUTE </center>  



### Return Loss Analysis

#### Plot 4.1: All S11 Data

This plot is used to visualize the S11 data taken over the course of the `r total_cycles` mating cycles on the `r company` `r cable_name`. The color of each trace corresponds to which mating cycle the data sample was taken on with red indicating earlier measurements and purple indicating later measurements.


```{r Plotting4.1, echo = FALSE, warning = FALSE}
# Load the data
df_melt_S11 <- melt(df, id.vars = c("Freq_GHz","Cycle","S11_spec_falcon","S11_spec_mx44", "S11_spec_low","S11_spec_mid","S11_spec_high"), measure.vars = c("S11_dB"))
names(df_melt_S11) <- c("Frequency", "Cycle", "S11_spec_falcon","S11_spec_mx44", "S11_spec_low","S11_spec_mid","S11_spec_high", "variable", "Return Loss")

# Create the plot
title <- paste(company, " ", cable_name, ": S11 Data over ", total_cycles, " cycles", sep = "")  
p <- ggplot(data = df_melt_S11, mapping = aes(x = Frequency)) + 
  geom_line(aes(y = `Return Loss`, color = Cycle)) +
  #xlim(0,43.5) +
  labs(x = "Frequency (GHz)", y = "Magnitude of S11 (dB)", col = "Cycle") +
  ggtitle(title) +
  scale_color_gradientn(colors = rainbow(5)) #+ 
  #theme(plot.title = element_text(size = 18, face = "bold"), axis.title = element_text(size = 18), axis.text = element_text(size = 14), 
        #legend.text = element_text(size=14), legend.title=element_text(size=14))

# Add specs to the plot if desired
if(s11_spec == "low"){
  Spec <- df_melt_S11$S11_spec_low
  p <- p + geom_line(aes(y = Spec), color = "red")
} else if (s11_spec == "mid"){
  Spec <- df_melt_S11$S11_spec_mid
  p <- p + geom_line(aes(y = Spec), color = "red")
} else if (s11_spec == "high"){
  Spec <- df_melt_S11$S11_spec_high
  p <- p + geom_line(aes(y = Spec), color = "red")
} else if (s11_spec == "mx44"){
  Spec <- df_melt_S11$S11_spec_mx44
  p <- p + geom_line(aes(y = Spec), color = "red")
} else if (s11_spec == "Falcon"){
  Spec <- df_melt_S11$S11_spec_falcon
  p <- p + geom_line(aes(y = Spec), color = "red")
}


# Generate the plot
p <- ggplotly(p, dynamicTicks = TRUE) %>% layout(xaxis = list(autorange = FALSE))
p <- config(p, modeBarButtonsToRemove = c("zoomIn2d", "zoomOut2d", "lasso2d", "select2d", "toggleSpikelines","autoScale2d"))
p
```
Pass or fail S11 spec: `r if(sum(!df$pass_S11_spec) > 0){paste("FAILED AT CYCLE ", df$Cycle[which(df$pass_S11_spec == FALSE)[1]], " OUT OF ", total_cycles, " CYCLES", sep = "")} else {paste("PASS")}`

<center> TERADYNE CONFIDENTIAL DO NOT DISTRIBUTE </center>  


#### Plot 4.2: Max, Min, and Mean of S11

This plot is used to calculate and visualize the maximum, minimum, and mean of S11 at each frequency over the `r total_cycles` cycles preformed on the `r company` `r cable_name`:

```{r Plotting4.2, echo = FALSE, warning = FALSE}
# Standard deviation of S11 across frequencies

# Create the title
title <- "Return Loss Max, Min, and Mean"

# Grab the needed subset of data
temp <- data.frame(smry$Freq_GHz, smry$max_S11_dB, smry$min_S11_dB, smry$mean_S11_dB)
names(temp) <- c("Frequency", "Max S11", "Min S11", "Mean S11")

# Create the plot
p <- ggplot(data = temp, mapping = aes(x = Frequency)) +
     geom_line(aes(y = `Max S11`), color = "red") +
     labs(x = "Frequency (GHz)", y = "Magnitude of S11 (dB)") +
     ggtitle(title)# +


      
# Add the spec line to the plot
p <- p + geom_line(aes(y = `Min S11`), color = "blue") +
         geom_line(aes(y = `Mean S11`), color = "black") +
         #labs(x = "Frequency (GHz)", y = "Spec")
         theme(legend.position = "none")

# Plot it
# Generate the plot
p11mmm <- ggplotly(p, dynamicTicks = TRUE) %>% layout(xaxis = list(autorange = FALSE))
p11mmm <- config(p11mmm, modeBarButtonsToRemove = c("zoomIn2d", "zoomOut2d", "lasso2d", "select2d", "toggleSpikelines","autoScale2d"))
p11mmm
```

<center> TERADYNE CONFIDENTIAL DO NOT DISTRIBUTE </center>  




#### Plot 6.1: S11 Data at `r closest_freq_low` GHz

This plot is the same as the above plot but the data was taken at `r closest_freq_low` GHz instead of `r closest_freq_low` GHz. There are `r total_cycles` cycles included in this plot. This plot can be used to get an idea of how the cable is degrading over time.

```{r Plotting6.1, echo = FALSE}
# Plot all S11 from all measurements
df_melt_S11 <- melt(df, id.vars = c("Freq_GHz","Cycle"), measure.vars = c("S11_dB"))

df_melt_S11_select_freq <- df_melt_S11[which(df_melt_S11$`Freq_GHz` == closest_freq_low),]

#title <- paste(company, " ", cable_name, ": S11 Data at ", closest_freq_low, " GHz over ", total_cycles, " cycles", sep = "")  
title <- paste(company, " ", ": S11 Data at ", closest_freq_low, " GHz over ", total_cycles, " cycles", sep = "")  

p <- ggplot(data = df_melt_S11_select_freq, mapping = aes(x = Cycle, y = value)) + 
      #geom_line(size = 0.5) +
      geom_line() +
      xlab("Cycle Number") + 
      ylab("Magnitude of S11 (dB)") + 
      ggtitle(title) #+
      #theme(plot.title = element_text(size = 18, face = "bold"), axis.title = element_text(size = 18), axis.text = element_text(size = 14), 
            #legend.text = element_text(size=14), legend.title=element_text(size=14))

# Generate the plot
p <- ggplotly(p, dynamicTicks = TRUE) %>% layout(xaxis = list(autorange = FALSE))
p <- config(p, modeBarButtonsToRemove = c("zoomIn2d", "zoomOut2d", "lasso2d", "select2d", "toggleSpikelines","autoScale2d"))
p
```
<center> TERADYNE CONFIDENTIAL DO NOT DISTRIBUTE </center>  



#### Plot 6.2: S11 Data at `r closest_freq_high` GHz

This plot is used to visualize the S11 data taken at `r closest_freq_high` GHz over the course of the `r total_cycles` cycles on the `r company` `r cable_name`. This plot can be used to get an idea of how the cable is degrading over time.

```{r Plotting6.2, echo = FALSE}
# Plot all S11 from all measurements
df_melt_S11 <- melt(df, id.vars = c("Freq_GHz","Cycle"), measure.vars = c("S11_dB"))

df_melt_S11_select_freq <- df_melt_S11[which(df_melt_S11$`Freq_GHz` == closest_freq_high),]

#title <- paste(company, " ", cable_name, ": S11 Data at ", closest_freq_high, " GHz over ", total_cycles, " cycles", sep = "")  
title <- paste(company, " ", ": S11 Data at ", closest_freq_high, " GHz over ", total_cycles, " cycles", sep = "")  

p <- ggplot(data = df_melt_S11_select_freq, mapping = aes(x = Cycle, y = value)) + 
  #geom_line(size = 0.5) +
  geom_line() +
  xlab("Cycle Number") + 
  ylab("Magnitude of S11 (dB)") + 
  ggtitle(title) #+
  #theme(plot.title = element_text(size = 18, face = "bold"), axis.title = element_text(size = 18), axis.text = element_text(size = 14), 
        #legend.text = element_text(size=14), legend.title=element_text(size=14))

# Generate the plot
p <- ggplotly(p, dynamicTicks = TRUE) %>% layout(xaxis = list(autorange = FALSE))
p <- config(p, modeBarButtonsToRemove = c("zoomIn2d", "zoomOut2d", "lasso2d", "select2d", "toggleSpikelines","autoScale2d"))
p
```
<center> TERADYNE CONFIDENTIAL DO NOT DISTRIBUTE </center>  




#### Plot 7.1: Phase at `r closest_freq_high` GHz

This plot is used to visualize the phase of the `r company` `r cable_name` insertion loss measurements at `r closest_freq_high` GHz over the `r total_cycles` cycles in this data set. 

```{r Plotting7.1, echo = FALSE}

#This section calculates and plots the average electrical length for the S21 measurements based on the S21 phase measurements at each frequency. The equation used to calculate electrical length is: e_length = (S21 phase / 2pi) / (Frequency * 360)

# Plot all S21 from all measurements
df_melt_S21 <- melt(df, id.vars = c("Freq_GHz","Cycle"), measure.vars = c("S21_Phase_Deg"))
df_melt_S21_rev <- df_melt_S21[which(df_melt_S21$`Freq_GHz` == closest_freq_high),]

# Calculate the electrical length
lambda <- 300000000 / closest_freq_high
degrees <- df_melt_S21_rev$value * (180 / pi)
e_length <- (degrees / 360) * lambda

# cbind it to the data frame
df_melt_S11_rev <- cbind(df_melt_S21_rev, e_length)


# Create the plot title
#title <- paste(company, " ", cable_name, ": S21 Phase at ", closest_freq_high, " over ", total_cycles, " Cycles", sep = "")
title <- paste(company, " ", ": S21 Phase at ", closest_freq_high, " over ", total_cycles, " Cycles", sep = "")

p <- ggplot(data = df_melt_S21_rev, mapping = aes(x = Cycle, y = value)) +
      #geom_point() +
      geom_line() +
      xlab("Number of Cycles") +
      ylab("Phase of S21 (Degrees)") +
      ggtitle(title) +
      #theme(plot.title = element_text(size = 18, face = "bold"), axis.title = element_text(size = 18), axis.text = element_text(size = 14), 
            #legend.position = "none")
      theme(legend.position = "none")

# Generate the plot
p <- ggplotly(p, dynamicTicks = TRUE) %>% layout(xaxis = list(autorange = FALSE))
p <- config(p, modeBarButtonsToRemove = c("zoomIn2d", "zoomOut2d", "lasso2d", "select2d", "toggleSpikelines","autoScale2d"))
p
```
<center> TERADYNE CONFIDENTIAL DO NOT DISTRIBUTE </center>  


 


```{r Plotting7.2, echo = FALSE, warning = FALSE}
# Standard deviation of S21 across frequencies


#### Plot 7.2: Repeatability of Phase 

#This plot is used to visualize the repeatability of the `r company` `r cable_name` insertion loss phase measurements at over the `r total_cycles` cycles in this data set.


if(num_cables == 1){
  # Grab the needed subset of data
  temp <- group_by(df,`Freq_GHz`) %>%
    summarise(sd_S21_Phase_Deg = sd(abs(S21_Phase_Deg)))
  names(temp) <- c("Frequency", "Repeatability (Degrees)")
  
  # Create the title
  title <- "Insertion Loss Phase Repeatability: Standard Deviation of S21 Phase"
  
  # Create the plot
  p <- ggplot(data = temp, mapping = aes(x = Frequency)) +
       geom_line(aes(y = `Repeatability (Degrees)`)) +
       labs(x = "Frequency (GHz)", y = "Standard Deviation of S21 Phase (Degrees)") +
       ggtitle(title)# +
  
  
  # Plot it
  # Generate the plot
  p21pr <- ggplotly(p, dynamicTicks = TRUE) %>% layout(xaxis = list(autorange = FALSE))
  p21pr <- config(p21pr, modeBarButtonsToRemove = c("zoomIn2d", "zoomOut2d", "lasso2d", "select2d", "toggleSpikelines","autoScale2d"))
  p21pr
}


```





```{r Plotting7.3, echo = FALSE, warning = FALSE}

#### Plot 7.3: S21 Phase Standard Deviation Calculated After Each Cycle

#This plot is used to calculate and visualize the standard deviation of S21 phase at all frequencies over the `r total_cycles` cycles preformed on the `r company` `r cable_name`. Measurements were taken every `r cycs_between_meas` cycles for a total of `r length(list.files(pth))` measurements. The standard deviation was recalculated after every measurement to see how the standard deviation changed over time. This plot is removed if data from multiple cables are included in analysis.



if(num_cables == 1){
  temp_df <- df[which(df$sd_by_cycle_phase > 0),]

  temp <- data.frame(df$Freq_GHz, df$sd_by_cycle_phase, df$Cycle)
  names(temp) <- c("Frequency","Repeatability", "Cycle")
  temp <- temp[which(temp$Repeatability > 0),]
  
  # Create the plot title
  title <- "Phase Repeatability: Standard Deviation of S21 Phase Calculated Every Cycle"
  
  # Create the plot
  p <- ggplot(data = temp, mapping = aes(x = Frequency)) + 
    geom_line(aes(y = Repeatability, color = Cycle)) +
    labs(x = "Frequency (GHz)", y = "Standard Deviation of S21 Phase (Degrees)", col = "Cycle") + 
    ggtitle(title) +
    scale_color_gradientn(colors = rainbow(5)) +
    guides(fill=guide_legend(title="Cycle"))
  
  
  # Generate the plot
  p21rcyc <- ggplotly(p, dynamicTicks = TRUE) %>% layout(xaxis = list(autorange = FALSE))
  p21rcyc <- config(p21rcyc, modeBarButtonsToRemove = c("zoomIn2d", "zoomOut2d", "lasso2d", "select2d", "toggleSpikelines","autoScale2d"))
  p21rcyc
}


```






```{r Plotting 8.2, echo = FALSE, warning = FALSE}
# Plot Phase Calculations

df_melt_phase <- melt(df, id.vars = c("Freq_GHz","Cycle"), measure.vars = c("S21_Phase_Deg"))
names(df_melt_phase) <- c("Frequency", "Cycle", "variable", "Phase")
    
title <- "Phase vs Frequency"
p <- ggplot(data = df_melt_phase, mapping = aes(x = Frequency, y = Phase, color = Cycle)) +
  geom_line(size = 0.5) +
  labs(x = "Frequency (GHz)", y = "Phase", col = "Cycle") +
  ggtitle(title) +
  scale_color_gradientn(colors = rainbow(5))

pphase <- ggplotly(p, dynamicTicks = TRUE)
pphase

```


```{r 3D S21 Plot, echo = FALSE, warning = FALSE}

#### 3D S21 Plot
#This is an interactive 3D plot of S21 that shows S21 plotted normally on the Y and Z axis with the cycle count on the X axis.


plotly_melt <- melt(df, id.vars = c("Freq_GHz","Cycle","meas"), measure.vars = c("S21_dB"))
plotly_melt <- data.frame(plotly_melt)
#plotly_melt$Cycle <- as.integer(plotly_melt$Cycle)

#setattr(plotly_melt, "row.names", c(paste(rownames(plotly_melt),plotly_melt$Cycle)))

p <- plot_ly(x = plotly_melt$Cycle[which(plotly_melt$meas == 1)], 
             y = plotly_melt$Freq_GHz[which(plotly_melt$meas == 1)], 
             z = plotly_melt$value[which(plotly_melt$meas == 1)], type = 'scatter3d', mode = 'lines', opacity = 1, 
             color = plotly_melt$Cycle[which(plotly_melt$meas == 1)], line = list(reverscale = TRUE)) %>% 
    layout(
      title = "Interactive 3D Plot of S21",
      scene = list(
        xaxis = list(title = "Cycle"),
        yaxis = list(title = "Frequency (GHz)"),
        zaxis = list(title = "S21 Magnitude (dB)")
    ))


for( i in 2:length(unique(plotly_melt$meas))){
  p <- add_trace(p, x = plotly_melt$Cycle[which(plotly_melt$meas == i)],
                    y = plotly_melt$Freq_GHz[which(plotly_melt$meas == i)], 
                    z = plotly_melt$value[which(plotly_melt$meas == i)], type = 'scatter3d', mode = 'lines', opacity = 1, 
                    color = plotly_melt$Cycle[which(plotly_melt$meas == i)], line = list(reverscale = TRUE))
}


p <- p %>% layout(showlegend = FALSE)
p <- p %>% config(modeBarButtonsToRemove = c("zoomIn2d", "zoomOut2d", "lasso2d", "select2d", "toggleSpikelines","autoScale2d"))
p

```
<center> TERADYNE CONFIDENTIAL DO NOT DISTRIBUTE </center>  












